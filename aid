#!/bin/bash

# Agentic Deployment Integration CLI (Pure Shell Version)
# Uses curl and python3 (standard on macOS/Linux)
# No Node.js or npm required.

set -e

CONFIG_FILE=".env"
GEMINI_MODEL="gemini-3-flash-preview-12-2025"
AID_VERSION="1.0.1"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# --- Commands ---

cmd_version() {
    echo -e "${BOLD}ü§ñ Agentic Deployment Integration${NC} ${BLUE}v$AID_VERSION${NC}"
    # Optional: System info
    # echo -e "   ${GREEN}‚Ä¢${NC} System: $(uname -s)"
}

cmd_update() {
    echo -e "${CYAN}üîÑ Checking for updates...${NC}"
    
    # 1. Fetch latest version number from GitHub
    latest_version=$(curl -s "https://raw.githubusercontent.com/adewumi0550/agentic_ai_serverless_js/main/aid" | grep '^AID_VERSION=' | cut -d'=' -f2 | tr -d '"')
    
    if [ -z "$latest_version" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Could not fetch latest version info.${NC}"
        # Fallback to force update if check fails? Or just ask user.
        read -p "Force update? [y/N] " force
        if [[ ! "$force" =~ ^[Yy]$ ]]; then exit 0; fi
    else
        if [ "$latest_version" == "$AID_VERSION" ]; then
            echo -e "${GREEN}‚úÖ You are already on the latest version ($AID_VERSION).${NC}"
            exit 0
        fi
        echo -e "${BLUE}üöÄ New version available: $latest_version${NC} (Current: $AID_VERSION)"
    fi

    echo "   Fetching latest installer from GitHub..."
    if curl -fsSL https://raw.githubusercontent.com/adewumi0550/agentic_ai_serverless_js/main/install.sh | bash; then
        echo ""
        echo -e "${GREEN}‚úÖ Update complete!${NC}"
        echo "   New version:"
        "$0" version
    else
        echo -e "${RED}‚ùå Update failed. Please check your internet connection.${NC}"
        exit 1
    fi
}

# 1. Configuration
cmd_config() {
    load_config
    if [ -z "$1" ]; then
        echo "üîß Configuration"
        if [ -f "$CONFIG_FILE" ]; then
            cat "$CONFIG_FILE"
        else
            echo "No configuration file found."
        fi
        echo ""
        echo "Usage: ./aid config [key] [value]"
        echo "       ./aid config [key] --delete"
        echo "Example: ./aid config GEMINI_MODEL gemini-1.5-pro"
        return
    fi

    key="$1"
    val="$2"

    if [[ "$val" == "--delete" || "$val" == "-d" ]]; then
        if [ -f "$CONFIG_FILE" ]; then
            # Delete all occurrences of the key (fixes duplicates too)
            sed -i '' "/^$key=/d" "$CONFIG_FILE"
            echo "üóëÔ∏è  Deleted $key from $CONFIG_FILE"
        else
            echo "‚ùå No config file found."
        fi
        return
    fi

    if [ -z "$val" ]; then
        # Get value
        val=$(grep "^$key=" "$CONFIG_FILE" | cut -d'=' -f2)
        echo "$key=$val"
    else
        # Set value
        # First, remove existing to avoid duplicates (sanitize state)
        if [ -f "$CONFIG_FILE" ]; then
             sed -i '' "/^$key=/d" "$CONFIG_FILE"
        fi
        # Append new
        echo "$key=\"$val\"" >> "$CONFIG_FILE"
        echo "‚úÖ Set $key=\"$val\""
    fi
}

# Helper to ensure .gitignore has essential entries
ensure_gitignore() {
    TOUCHED=0
    if [ ! -f ".gitignore" ]; then
        touch .gitignore
        echo -e "${GREEN}‚úÖ Created .gitignore${NC}"
        TOUCHED=1
    fi

    # List of patterns to enforce
    IGNORES=(
        "node_modules/"
        "dist/"
        "build/"
        ".env"
        ".DS_Store"
        ".aid/"
        "aid_reports/"
        "yarn-cache/"
        "coverage/"
        "*.log"
    )

    for pattern in "${IGNORES[@]}"; do
        if ! grep -qF "$pattern" ".gitignore"; then
            echo "$pattern" >> .gitignore
            echo -e "   ${YELLOW}+ Added $pattern to .gitignore${NC}"
            TOUCHED=1
        fi
    done

    if [ "$TOUCHED" -eq 1 ]; then
        echo -e "${GREEN}üîí Secured project workspace.${NC}"
    fi
}

cmd_init() {
    echo "üëã Welcome to Agentic Deployment Integration"
    
    # 1. Setup Gemini Key
    # 1. Setup Gemini Key
    target_config=".aid/config"
    mkdir -p ".aid"
    
    # Secure: Add to .gitignore if not present
    ensure_gitignore

    # Check if global config exists and load it
    if [ -f "$GLOBAL_CONFIG_FILE" ]; then
        source_config "$GLOBAL_CONFIG_FILE" # Helper to load
    fi
    # Check for local .aid/config
    if [ -f "$target_config" ]; then
        source_config "$target_config"
    fi

    if [ -z "$GEMINI_API_KEY" ]; then
        while true; do
            read -sp "Enter your Gemini API Key: " api_key
            echo ""
            
            if [ -z "$api_key" ]; then
                echo "‚ùå API Key cannot be empty."
                continue
            fi

            echo "Testing API Key..."
            response=$(curl -s -o /dev/null -w "%{http_code}" "https://generativelanguage.googleapis.com/v1beta/models?key=$api_key")

            if [ "$response" -eq 200 ]; then
                echo "‚úÖ API Key is valid!"
                break
            else
                echo "‚ùå Invalid API Key (HTTP $response). Please try again."
            fi
        done
        
        echo "Where do you want to save this key?"
        echo "  (l) Local Secure (.aid/config) - Recommended"
        echo "  (g) Global (~/.aid/config) - Developer defaults"
        read -p "Select [l/g]: " save_loc
        
        if [[ "$save_loc" == "g" ]]; then
            mkdir -p "$GLOBAL_CONFIG_DIR"
            target_config="$GLOBAL_CONFIG_FILE"
            echo "Saving to global config: $target_config"
        else
            target_config=".aid/config"
            echo "Saving to local secure config: $target_config"
        fi

        echo "GEMINI_API_KEY=\"$api_key\"" >> "$target_config"
        echo "GEMINI_MODEL=\"$GEMINI_MODEL\"" >> "$target_config"
        export GEMINI_API_KEY="$api_key"
        
        echo ""
    else
        echo "‚úÖ Gemini API Key found."
    fi

    # 2. Detect Stack (Interactive or Auto)
    echo ""
    echo "üîç Configuration Setup"
    echo "------------------------"
    
    # Language
    if [ -f "package.json" ]; then default_lang="Node.js"; 
    elif [ -f "requirements.txt" ]; then default_lang="Python";
    elif [ -f "go.mod" ]; then default_lang="Go";
    elif [ -f "pubspec.yaml" ]; then default_lang="Flutter/Dart";
    elif [ -f "composer.json" ]; then default_lang="PHP";
    elif [ -f "index.html" ]; then default_lang="HTML/Web";
    else default_lang="Unknown"; fi
    
    read -p "Project Language [$default_lang]: " input_lang
    lang="${input_lang:-$default_lang}"
    echo "PROJECT_LANGUAGE=\"$lang\"" >> "$target_config"
    
    # Project Type
    echo ""
    echo "Select Project Type:"
    echo "  1) Web App (Frontend/Fullstack)"
    echo "  2) API / Backend Service"
    echo "  3) Mobile App"
    echo "  4) CLI Tool"
    echo "  5) Other"
    read -p "Enter Choice [1]: " type_choice
    
    case "${type_choice:-1}" in
        1) proj_type="Web App" ;;
        2) proj_type="API/Backend" ;;
        3) proj_type="Mobile App" ;;
        4) proj_type="CLI Tool" ;;
        *) proj_type="Other" ;;
    esac
    echo "PROJECT_TYPE=\"$proj_type\"" >> "$target_config"
    
    echo ""
    echo "‚úÖ Setup Complete!"
    echo "   Configuration saved to $target_config"
    echo "   Run './aid deploy' when you are ready to configure deployment."
}

# 2. Agentic Workflows

cmd_ask() {
    check_config
    if [ -z "$1" ]; then
        echo "‚ùå Usage: ./aid ask \"your question about the codebase\""
        exit 1
    fi
    echo "ü§î Thinking..."
    context=$(scan_codebase)
    prompt="You are an expert developer. Answer this question based on the codebase context provided.\n\nContext:\n$context\n\nQuestion: $1"
    call_gemini "$prompt" "aid_answer.md"
}

cmd_review() {
    check_config
    echo "üßê Reviewing codebase..."
    context=$(scan_codebase)
    prompt="You are a senior staff engineer. Perform a thorough code review of this codebase. Focus on security, performance, and maintainability. Structure your response with a summary followed by file-by-file comments."
    call_gemini "$prompt" "code_review.md" 
}

cmd_refactor() {
    check_config
    if [ -z "$1" ]; then
        echo "‚ùå Usage: ./aid refactor <file_path> \"refactoring instructions\""
        exit 1
    fi
    file="$1"
    instruction="$2"
    
    if [ ! -f "$file" ]; then
        echo "‚ùå File $file not found."
        exit 1
    fi
    
    content=$(cat "$file")
    echo "üîß Refactoring $file..."
    prompt="You are an expert refactorer. Refactor the code in '$file' according to these instructions: '$instruction'. \n\nOriginal Code:\n$content\n\nReturn ONLY the full refactored code block."
    call_gemini "$prompt" "${file}.refactored"
}

cmd_analyze() {
    check_config
    echo "üîç Analyzing project structure and infrastructure..."
    
    # 1. Detect Infrastructure
    infra_context=""
    if [ -f "Dockerfile" ]; then infra_context="$infra_context\n- Dockerfile detected."; fi
    if [ -f "docker-compose.yml" ]; then infra_context="$infra_context\n- Docker Compose detected."; fi
    if [ -f "go.mod" ]; then infra_context="$infra_context\n- Go detected."; fi
    if [ -f "composer.json" ]; then infra_context="$infra_context\n- PHP/Composer detected."; fi
    if [ -f "index.html" ]; then infra_context="$infra_context\n- HTML detected."; fi
    
    # 2. Gather File Context
    code_context=$(scan_codebase)
    
    # Save context for user reference
    mkdir -p "aid_reports"
    echo "$code_context" > "aid_reports/project_context.txt"
    echo "üìÑ Project context saved to aid_reports/project_context.txt"
    
    # 3. User Rules
    user_rules=""
    if [ -f ".aid/rules.md" ]; then
        user_rules="\n\nUSER CONFIG / RULES:\n$(cat .aid/rules.md)\n"
    fi
    
    # Load previously saved project info if available
    proj_lang="${PROJECT_LANGUAGE:-Auto-Detect}"
    proj_type="${PROJECT_TYPE:-Auto-Detect}"
    
    # 4. Build Prompt
    prompt="You are a Principal DevOps Engineer and Software Architect. I need a DEEP DIVE 'Agentic Deployment Integration' report for this workspace.\n\n"
    prompt="${prompt}Project Config: Language='$proj_lang', Type='$proj_type'\n"
    prompt="${prompt}Infrastructure Context:${infra_context}\n\n"
    prompt="${prompt}Codebase Context:\n${code_context}\n${user_rules}\n"
    prompt="${prompt}Please provide a comprehensive report DETAILED for this specific project type:\n"
    prompt="${prompt}1. **Executive Summary**: Identify if this is a Static Web App, SPA, Serverless Backend, or Containerized Service.\n"
    prompt="${prompt}2. **Stack Analysis**: Language, framework, dependencies.\n"
    prompt="${prompt}   - IF WEB/HTML: Analyze for SEO tags, performance best practices (minification), and responsive design indicators.\n"
    prompt="${prompt}   - IF BACKEND: Analyze for API structure, database connections, and middleware.\n"
    prompt="${prompt}   - IF MOBILE (Flutter): Analyze for state management (BLoC/Provider), widget structure, and asset optimization.\n"
    prompt="${prompt}   - IF PHP/Legacy: Analyze for modern practices, security (SQLi), and migration paths.\n"
    prompt="${prompt}3. **Architecture & Flow**: \n"
    prompt="${prompt}   - IF WEB: Recommend hosting (Vercel/Netlify/Firebase Hosting) and CDN strategy.\n"
    prompt="${prompt}   - IF BACKEND: Recommend Compute (Cloud Run/Lambda) and Database (SQL/NoSQL).\n"
    prompt="${prompt}   - IF MOBILE: Recommend app store CI/CD (Fastlane), OTA updates, and backend integration.\n"
    prompt="${prompt}4. **Security Audit**: \n"
    prompt="${prompt}   - IF WEB: Check for XSS risks, CSP headers, exposed keys in client-side code.\n"
    prompt="${prompt}   - IF BACKEND: Check for injection risks, IAM roles, and secret management.\n"
    prompt="${prompt}   - IF MOBILE: Check for insecure storage, API key exposure in binary, and deep link validation.\n"
    prompt="${prompt}5. **Action Plan**: Detailed roadmap to get this specific project to production.\n\n"
    prompt="${prompt}Format the output as a clean, professional Markdown report."

    echo "üß† Generating Agentic Report..."
    call_gemini "$prompt" "aid_reports/deployment_plan.md"
    cp "aid_reports/deployment_plan.md" "AGENTIC_REPORT.md" # Keep legacy link for now
    log_history "analyze"
}

cmd_docs() {
    check_config
    echo "üìö Generating documentation..."
    context=$(scan_codebase)
    prompt="Generate comprehensive documentation for this project. Include an Overview, Setup Guide, API Reference (if applicable), and Architecture description. Output in Markdown."
    call_gemini "$prompt" "PROJECT_DOCS.md"
    log_history "docs"
}

cmd_report() {
    if [ ! -f "AGENTIC_REPORT.md" ]; then
        echo "‚ö†Ô∏è  No report found. Generating one now..."
        cmd_analyze
    fi
    
    echo "üìÑ Displaying Agentic Report..."
    echo "--------------------------------------------------"
    if command -v mdcat >/dev/null 2>&1; then
        mdcat "AGENTIC_REPORT.md"
    else
        cat "AGENTIC_REPORT.md"
    fi
    echo "--------------------------------------------------"
}

cmd_generate() {
    check_config
    if [ -z "$1" ]; then
        echo "‚ùå Usage: ./aid gen \"Describe the code you want to generate\""
        exit 1
    fi
    echo "üë®‚Äçüíª Generating code..."
    prompt="You are an expert software engineer. Generate high-quality, production-ready code for the following request. Return ONLY the code/markdown.\n\nRequest: $1"
    call_gemini "$prompt" "generated_code.md"
    log_history "gen"
}

cmd_history() {
    if [ -f ".aid/history.log" ]; then
        echo "üìú Developer History:"
        cat ".aid/history.log"
    else
        echo "No history yet."
    fi
}

# 3. Core & Serverless

cmd_start() {
    echo "üöÄ Starting local server..."
    # Placeholder: Detect project type and run appropriate start command
    if [ -f "package.json" ]; then npm start; 
    elif [ -f "main.py" ]; then python3 main.py;
    elif [ -f "composer.json" ]; then php -S localhost:8000;
    elif [ -f "index.html" ]; then python3 -m http.server;
    else echo "UNKNOWN PROJECT TYPE. Please add a start script."; fi
}

cmd_deploy() {
    check_config
    
    echo "üïµÔ∏è  Agentic Deployment Initiated..."
    echo "---------------------------------"
    
    # 1. Check/Set Deployment Platform
    if [ -z "$DEPLOYMENT_PLATFORM" ]; then
        echo "üöÄ Choose your deployment target:"
        echo "1. AWS"
        echo "2. GCP (Google Cloud)"
        echo "3. Vercel"
        echo "4. Render"
        echo "5. DigitalOcean"
        echo "6. Other (Generic)"
        read -p "Select (1-6): " platform_choice

        case "$platform_choice" in
            1)
                platform="AWS"
                read -p "AWS Access Key ID: " aws_key
                read -sp "AWS Secret Access Key: " aws_secret
                echo ""
                if [ -f "$CONFIG_FILE" ]; then
                    echo "AWS_ACCESS_KEY_ID=\"$aws_key\"" >> "$CONFIG_FILE"
                    echo "AWS_SECRET_ACCESS_KEY=\"$aws_secret\"" >> "$CONFIG_FILE"
                fi
                ;;
            2)
                platform="GCP"
                read -p "GCP Project ID: " gcp_project
                if [ -f "$CONFIG_FILE" ]; then
                     echo "GCP_PROJECT_ID=\"$gcp_project\"" >> "$CONFIG_FILE"
                fi
                echo "‚ÑπÔ∏è  Note: Ensure you have 'gcloud' installed and authenticated."
                ;;
            3)
                platform="Vercel"
                read -sp "Vercel Token: " vercel_token
                echo ""
                if [ -f "$CONFIG_FILE" ]; then
                    echo "VERCEL_TOKEN=\"$vercel_token\"" >> "$CONFIG_FILE"
                fi
                ;;
            4)
                platform="Render"
                read -sp "Render API Key: " render_key
                echo ""
                if [ -f "$CONFIG_FILE" ]; then
                    echo "RENDER_API_KEY=\"$render_key\"" >> "$CONFIG_FILE"
                fi
                ;;
            5)
                platform="DigitalOcean"
                read -sp "DO Personal Access Token: " do_token
                echo ""
                if [ -f "$CONFIG_FILE" ]; then
                    echo "DIGITALOCEAN_TOKEN=\"$do_token\"" >> "$CONFIG_FILE"
                fi
                ;;
            *)
                platform="Generic"
                ;;
        esac
        
        echo "DEPLOYMENT_PLATFORM=\"$platform\"" >> "$CONFIG_FILE"
        export DEPLOYMENT_PLATFORM="$platform"
        echo "‚úÖ Platform configured: $platform"
    else
        echo "‚úÖ Platform already configured: $DEPLOYMENT_PLATFORM"
        platform="$DEPLOYMENT_PLATFORM"
    fi

    # 4. Generate Deployment Plan (if not exists or forced)
    echo -e "${CYAN}üß† Generating deployment plan for $platform...${NC}"
    
    stack="${PROJECT_LANGUAGE:-Auto-Detect}"
    ptype="${PROJECT_TYPE:-Auto-Detect}"
    
    context=$(scan_codebase)
    prompt="You are a Principal DevOps Engineer. The user has a **$stack** project (Type: **$ptype**) and wants to deploy to **$platform**.\n\n"
    prompt="${prompt}**Project Context**:\n$context\n\n"
    prompt="${prompt}Generate a detailed **DEPLOYMENT_PLAN.md** structured as follows:\n"
    prompt="${prompt}### 1. üèóÔ∏è Architecture & Prerequisites\n"
    prompt="${prompt}- Necessary tools (CLI, accounts).\n"
    prompt="${prompt}- Expected costs/limits for $platform.\n"
    prompt="${prompt}### 2. ‚öôÔ∏è Configuration\n"
    prompt="${prompt}- Create/Update these files (Dockerfile, serverless.yml, etc.). provide FULL CODE content.\n"
    prompt="${prompt}### 3. üöÄ Deployment Steps\n"
    prompt="${prompt}- Step-by-step shell commands to deploy.\n"
    prompt="${prompt}- How to inject environment variables (referencing local .env keys).\n"
    prompt="${prompt}### 4. üîç Verification\n"
    prompt="${prompt}- How to check logs and health.\n\n"
    prompt="${prompt}Output ONLY valid Markdown. Use specific icons and headers to make it look professional."
    
    call_gemini "$prompt" "aid_reports/DEPLOYMENT_PLAN.md"
    cp "aid_reports/DEPLOYMENT_PLAN.md" "DEPLOYMENT_PLAN.md"

    echo -e "${GREEN}‚úÖ Plan Generated: DEPLOYMENT_PLAN.md${NC}"
    read -p "View plan now? [Y/n] " view_plan
    if [[ ! "$view_plan" =~ ^[Nn]$ ]]; then
        if command -v mdcat >/dev/null 2>&1; then mdcat "DEPLOYMENT_PLAN.md"; else cat "DEPLOYMENT_PLAN.md"; fi
    fi

    echo ""
    read -p "Proceed with automated deployment steps? [y/N] " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}‚ùå Deployment execution cancelled. Follow the manual plan above.${NC}"
        exit 0
    fi
    
    echo -e "${BLUE}üöÄ Executing deployment basics...${NC}"
    case "$platform" in
        AWS) echo "aws s3 sync . s3://bucket --dryrun" ;;
        GCP) echo "gcloud run deploy --source ." ;;
        Vercel) echo "vercel --prod" ;;
        *) echo "Generic deployment script" ;;
    esac
    log_history "deploy"
}

cmd_push() {
    check_config
    
    # Ensure ignores before adding
    ensure_gitignore
    
    # Safety: Remove cached ignored files if they were accidentally added
    IGNORED_ITEMS=("node_modules" "dist" "build" ".env" ".DS_Store" ".aid" "aid_reports" "yarn-cache" "coverage")
    for item in "${IGNORED_ITEMS[@]}"; do
        if git ls-files --error-unmatch "$item" >/dev/null 2>&1; then
             echo -e "${YELLOW}üßπ Removing $item from git index...${NC}"
             git rm -r --cached "$item" >/dev/null 2>&1
        fi
    done

    if [ ! -d ".git" ]; then
        echo "‚ùå Not a git repository."
        exit 1
    fi

    echo "üïµÔ∏è  Scanning for changes..."
    # Auto-stage all changes
    git add .
    
    # Check if there are changes to commit
    if git diff --cached --quiet; then
        echo "‚úÖ No changes to commit."
        # Check if there are commits to push
        unpushed=$(git log origin/main..HEAD 2>/dev/null)
        if [ -n "$unpushed" ]; then
             echo "üöÄ Pushing existing commits..."
             git push
             exit 0
        fi
        exit 0
    fi

    echo "üß† Generating semantic commit message..."
    
    # Get diff for context (limit lines to avoid huge payloads)
    diff_content=$(git diff --cached | head -n 50)
    
    prompt="You are a senior developer. Generate a CONCISE, Conventional Commit message (e.g., 'feat: ...', 'fix: ...', 'docs: ...') for this diff. Return ONLY the message string. Do not use quotes.\n\nDiff Context:\n$diff_content"
    
    # Generate message to a temp file
    call_gemini "$prompt" ".commit_msg.tmp" > /dev/null 2>&1
    
    if [ ! -f ".commit_msg.tmp" ]; then
        echo "‚ùå Failed to generate commit message."
        exit 1
    fi
    
    commit_msg=$(cat ".commit_msg.tmp")
    rm ".commit_msg.tmp"
    
    echo ""
    echo "--------------------------------------------------"
    echo "ü§ñ Proposed Commit Message:"
    echo "   $commit_msg"
    echo "--------------------------------------------------"
    echo ""
    
    echo "Do you want to proceed?"
    echo "  (y) Yes, commit and push"
    echo "  (n) No, abort"
    echo "  (e) Edit message manually"
    read -p "Select [y/n/e]: " choice
    
    case "$choice" in
        y|Y)
            echo "üöÄ Committing..."
            git commit -m "$commit_msg"
            echo "‚òÅÔ∏è  Pushing to remote..."
            git push
            echo "‚úÖ Done!"
            ;;
        e|E)
            read -p "Enter your commit message: " custom_msg
            git commit -m "$custom_msg"
            echo "‚òÅÔ∏è  Pushing to remote..."
            git push
            echo "‚úÖ Done!"
            ;;
        *)
            echo "‚ùå Aborted. Changes are staged."
            exit 0
            ;;
    esac
    log_history "push"
}

# --- Helpers ---

# --- Helpers ---

log_history() {
    local cmd="$1"
    local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    mkdir -p ".aid"
    echo "[$timestamp] $cmd" >> ".aid/history.log"
}

source_config() {
    local file="$1"
    if [ -f "$file" ]; then
        # Read file line by line
        while IFS='=' read -r key value || [ -n "$key" ]; do
            # Skip comments and empty lines
            [[ "$key" =~ ^#.*$ ]] && continue
            [[ -z "$key" ]] && continue
            
            # Remove leading 'export '
            key=${key#export }
            
            # Trim whitespace
            key=$(echo "$key" | xargs)
            
            # Validate key
            if [[ ! "$key" =~ ^[A-Z0-9_]+$ ]]; then continue; fi

            # Clean value
            value=${value%\"}
            value=${value#\"}
            value=${value%\'}
            value=${value#\'}
            
            # Export
            export "$key=$value"
        done < "$file"
    fi
}

load_config() {
    GLOBAL_CONFIG_FILE="$HOME/.aid/config"
    # Load Global first
    source_config "$GLOBAL_CONFIG_FILE"
    
    # Load Local Secure (.aid/config) - PRIMARY
    if [ -f ".aid/config" ]; then
        source_config ".aid/config"
        CONFIG_FILE=".aid/config" # Update current active config
    # Backwards compatibility / Override
    elif [ -f ".env" ]; then
        source_config ".env"
        CONFIG_FILE=".env"
    fi
}

check_config() {
    config_found=0
    if [ -f ".aid/config" ]; then config_found=1; fi
    if [ -f ".env" ]; then config_found=1; fi
    if [ -f "$HOME/.aid/config" ]; then config_found=1; fi

    if [ "$config_found" -eq 0 ]; then
        echo -e "${RED}‚ùå No configuration found.${NC}" 
        echo "   Run './aid init' to setup your project."
        exit 1
    fi
    
    load_config
    
    if [ -z "$GEMINI_API_KEY" ]; then
        echo -e "${RED}‚ùå GEMINI_API_KEY missing.${NC}"
        exit 1
    fi
    # Use config model or default
    if [ -n "$GEMINI_MODEL" ]; then GEMINI_MODEL="$GEMINI_MODEL"; fi
}

scan_codebase() {
    # Helper to gather context
    find . -maxdepth 2 -type f -not -path '*/.*' -not -path '*/node_modules*' -not -path '*/dist*' -not -name 'package-lock.json' -not -name '*.md' | head -n 20 | while read file; do
        if file "$file" | grep -q "text"; then
            echo "--- FILE: $file ---"
            cat "$file"
            echo ""
        fi
    done
}

call_gemini() {
    local prompt="$1"
    local output_file="$2"
    
    # Escape prompt for JSON
    json_payload=$(python3 -c "import json, sys; print(json.dumps({'contents': [{'parts': [{'text': sys.argv[1]}]}]}))" "$prompt")

    response=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        "https://generativelanguage.googleapis.com/v1beta/models/$GEMINI_MODEL:generateContent?key=$GEMINI_API_KEY" \
        -d "$json_payload")

    if echo "$response" | grep -q "\"error\":"; then
        echo "‚ùå API Error"
        # Check for 404 (Model Not Found)
        if echo "$response" | grep -q '"code": 404'; then
             echo "‚ÑπÔ∏è  The model '$GEMINI_MODEL' was not found or is not supported."
             echo "üîç Fetching available models for your key..."
             models_response=$(curl -s "https://generativelanguage.googleapis.com/v1beta/models?key=$GEMINI_API_KEY")
             if echo "$models_response" | grep -q "\"models\":"; then
                 echo "‚úÖ Available Models:"
                 echo "$models_response" | python3 -c "import sys, json; print('\n'.join([m['name'].replace('models/', '') for m in json.load(sys.stdin)['models']]))"
                 echo ""
                 echo "üëâ To use one of these, run: ./aid config GEMINI_MODEL <model_name>"
             else
                 echo "‚ùå Could not list models."
             fi
        else
            echo "$response"
        fi
        exit 1
    fi

    # Extract text
    report=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin)['candidates'][0]['content']['parts'][0]['text'])")
    
    echo "$report" > "$output_file"
    echo "‚úÖ Output saved to $output_file"
    echo ""
    # Optional: Print preview
    echo "$report" | head -n 10
    echo "... (full output in $output_file)"
}


cmd_help() {
    echo "ü§ñ Agentic Deployment Integration CLI"
    echo "usage: ./aid <command> [args]"
    echo ""
    echo "Core:"
    echo "  init        Setup API Key"
    echo "  config      View or update configuration (e.g., ./aid config GEMINI_MODEL gemini-1.5-pro)"
    echo "  version     Show version info"
    echo "  update      Update aid to the latest version"
    echo "  update      Update aid to the latest version"
    echo "  history     View command history"
    echo "  clean       Clear the terminal screen"
    echo "  help        Show this list"
    echo ""
    echo "Agentic AI:"
    echo "  ask         Ask a question about your codebase"
    echo "  analyse     Analyze architecture & quality"
    echo "  review      Perform a comprehensive code review"
    echo "  refactor    Refactor a specific file (./aid refactor file.js \"instructions\")"
    echo "  gen         Generate code from a prompt"
    echo "  docs        Generate project documentation (PROJECT_DOCS.md)"
    echo "  report      View last analysis report"
    echo ""
    echo "Serverless & Ops:"
    echo "  start       Start local server (auto-detects project type)"
    echo "  deploy      Deploy project (runs deploy.sh, sls deploy, etc.)"
    echo "  push        Smart Git Push (Auto-stage, AI Commit Message, Push)"
    echo "  push        Smart Git Push (Auto-stage, AI Commit Message, Push)"
    echo ""
}

cmd_clean() {
    clear
    echo -e "${GREEN}‚ú® Screen cleaned!${NC}"
    cmd_help
}

# --- Main Dispatch ---

case "$1" in
    init)       cmd_init ;;
    config)     cmd_config "$2" "$3" ;;
    version|-v|--version) cmd_version ;;
    update|upgrade) cmd_update ;;
    history)    cmd_history ;;
    ask)        cmd_ask "$2" ;;
    review)     cmd_review ;;
    refactor)   cmd_refactor "$2" "$3" ;;
    docs)       cmd_docs ;;
    analyse|analyze) cmd_analyze ;; # From previous scan logic (can alias to review or keep separate)
    generate|gen)    cmd_generate "$2" ;;
    report)     cmd_report ;;
    start)      cmd_start ;;
    deploy)     cmd_deploy ;;
    deploy)     cmd_deploy ;;
    push)       cmd_push ;;
    clean)      cmd_clean ;;
    *)          cmd_help ;;
esac
